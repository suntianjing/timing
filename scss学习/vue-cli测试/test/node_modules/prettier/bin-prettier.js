#!/usr/bin/env node
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var fs$1 = _interopDefault(require('fs'));
var os$1 = _interopDefault(require('os'));
var path$2 = _interopDefault(require('path'));
var assert$1 = _interopDefault(require('assert'));
var util$3 = _interopDefault(require('util'));
var events$1 = _interopDefault(require('events'));
var readline$1 = _interopDefault(require('readline'));

var name = "prettier";
var version = "1.19.1";
var description = "Prettier is an opinionated code formatter";
var bin = {
	prettier: "./bin/prettier.js"
};
var repository = "prettier/prettier";
var homepage = "https://prettier.io";
var author = "James Long";
var license = "MIT";
var main = "./index.js";
var engines = {
	node: ">=8"
};
var dependencies = {
	"@angular/compiler": "8.2.13",
	"@babel/code-frame": "7.5.5",
	"@babel/parser": "7.7.3",
	"@glimmer/syntax": "0.41.0",
	"@iarna/toml": "2.2.3",
	"@typescript-eslint/typescript-estree": "2.6.1",
	"angular-estree-parser": "1.1.5",
	"angular-html-parser": "1.3.0",
	camelcase: "5.3.1",
	chalk: "2.4.2",
	"cjk-regex": "2.0.0",
	cosmiconfig: "5.2.1",
	dashify: "2.0.0",
	dedent: "0.7.0",
	diff: "4.0.1",
	editorconfig: "0.15.3",
	"editorconfig-to-prettier": "0.1.1",
	"escape-string-regexp": "1.0.5",
	esutils: "2.0.3",
	"find-parent-dir": "0.3.0",
	"find-project-root": "1.1.1",
	"flow-parser": "0.111.3",
	"get-stream": "4.1.0",
	globby: "6.1.0",
	graphql: "14.5.8",
	"html-element-attributes": "2.2.0",
	"html-styles": "1.0.0",
	"html-tag-names": "1.1.4",
	ignore: "4.0.6",
	"is-ci": "2.0.0",
	"jest-docblock": "24.9.0",
	"json-stable-stringify": "1.0.1",
	leven: "3.1.0",
	"lines-and-columns": "1.1.6",
	"linguist-languages": "7.6.0",
	"lodash.uniqby": "4.7.0",
	mem: "5.1.1",
	minimatch: "3.0.4",
	minimist: "1.2.0",
	"n-readlines": "1.0.0",
	"normalize-path": "3.0.0",
	"parse-srcset": "ikatyang/parse-srcset#54eb9c1cb21db5c62b4d0e275d7249516df6f0ee",
	"postcss-less": "2.0.0",
	"postcss-media-query-parser": "0.2.3",
	"postcss-scss": "2.0.0",
	"postcss-selector-parser": "2.2.3",
	"postcss-values-parser": "1.5.0",
	"regexp-util": "1.2.2",
	"remark-math": "1.0.6",
	"remark-parse": "5.0.0",
	resolve: "1.12.0",
	semver: "6.3.0",
	"string-width": "4.1.0",
	typescript: "3.7.2",
	"unicode-regex": "3.0.0",
	unified: "8.4.1",
	vnopts: "1.0.2",
	"yaml-unist-parser": "1.1.1"
};
var devDependencies = {
	"@babel/core": "7.7.2",
	"@babel/preset-env": "7.7.1",
	"@rollup/plugin-alias": "2.2.0",
	"@rollup/plugin-replace": "2.2.1",
	"babel-loader": "8.0.6",
	benchmark: "2.1.4",
	"builtin-modules": "3.1.0",
	codecov: "3.6.1",
	"cross-env": "6.0.3",
	eslint: "6.6.0",
	"eslint-config-prettier": "6.5.0",
	"eslint-formatter-friendly": "7.0.0",
	"eslint-plugin-import": "2.18.2",
	"eslint-plugin-prettier": "3.1.1",
	"eslint-plugin-react": "7.16.0",
	execa: "3.2.0",
	jest: "23.3.0",
	"jest-junit": "9.0.0",
	"jest-snapshot-serializer-ansi": "1.0.0",
	"jest-snapshot-serializer-raw": "1.1.0",
	"jest-watch-typeahead": "0.4.0",
	mkdirp: "0.5.1",
	prettier: "1.19.0",
	prettylint: "1.0.0",
	rimraf: "3.0.0",
	rollup: "1.26.3",
	"rollup-plugin-babel": "4.3.3",
	"rollup-plugin-commonjs": "10.1.0",
	"rollup-plugin-json": "4.0.0",
	"rollup-plugin-node-globals": "1.4.0",
	"rollup-plugin-node-resolve": "5.2.0",
	"rollup-plugin-terser": "5.1.2",
	shelljs: "0.8.3",
	"snapshot-diff": "0.4.0",
	"strip-ansi": "5.2.0",
	"synchronous-promise": "2.0.10",
	tempy: "0.2.1",
	"terser-webpack-plugin": "2.2.1",
	webpack: "4.41.2"
};
var scripts = {
	prepublishOnly: "echo \"Error: must publish from dist/\" && exit 1",
	"prepare-release": "yarn && yarn build && yarn test:dist",
	test: "jest",
	"test:dist": "node ./scripts/test-dist.js",
	"test-integration": "jest tests_integration",
	"perf-repeat": "yarn && yarn build && cross-env NODE_ENV=production node ./dist/bin-prettier.js --debug-repeat ${PERF_REPEAT:-1000} --loglevel debug ${PERF_FILE:-./index.js} > /dev/null",
	"perf-repeat-inspect": "yarn && yarn build && cross-env NODE_ENV=production node --inspect-brk ./dist/bin-prettier.js --debug-repeat ${PERF_REPEAT:-1000} --loglevel debug ${PERF_FILE:-./index.js} > /dev/null",
	"perf-benchmark": "yarn && yarn build && cross-env NODE_ENV=production node ./dist/bin-prettier.js --debug-benchmark --loglevel debug ${PERF_FILE:-./index.js} > /dev/null",
	"check-types": "tsc",
	lint: "cross-env EFF_NO_LINK_RULES=true eslint . --format friendly",
	"lint-docs": "prettylint {.,docs,website,website/blog}/*.md",
	"lint-dist": "eslint --no-eslintrc --no-ignore --env=browser \"dist/!(bin-prettier|index|third-party).js\"",
	build: "node --max-old-space-size=3072 ./scripts/build/build.js",
	"build-docs": "node ./scripts/build-docs.js",
	"check-deps": "node ./scripts/check-deps.js",
	spellcheck: "npx -p cspell@4.0.31 cspell {bin,scripts,src}/**/*.js {docs,website/blog,changelog_unreleased}/**/*.md"
};
var _package = {
	name: name,
	version: version,
	description: description,
	bin: bin,
	repository: repository,
	homepage: homepage,
	author: author,
	license: license,
	main: main,
	engines: engines,
	dependencies: dependencies,
	devDependencies: devDependencies,
	scripts: scripts
};

var _package$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name,
  version: version,
  description: description,
  bin: bin,
  repository: repository,
  homepage: homepage,
  author: author,
  license: license,
  main: main,
  engines: engines,
  dependencies: dependencies,
  devDependencies: devDependencies,
  scripts: scripts,
  'default': _package
});

function Diff() {}

Diff.prototype = {
  diff: function diff(oldString, newString) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var callback = options.callback;

    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    this.options = options;
    var self = this;

    function done(value) {
      if (callback) {
        setTimeout(function () {
          callback(undefined, value);
        }, 0);
        return true;
      } else {
        return value;
      }
    } // Allow subclasses to massage the input prior to running


    oldString = this.castInput(oldString);
    newString = this.castInput(newString);
    oldString = this.removeEmpty(this.tokenize(oldString));
    newString = this.removeEmpty(this.tokenize(newString));
    var newLen = newString.length,
        oldLen = oldString.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;
    var bestPath = [{
      newPos: -1,
      components: []
    }]; // Seed editLength = 0, i.e. the content starts with the same values

    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);

    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
      // Identity per the equality and tokenizer
      return done([{
        value: this.join(newString),
        count: newString.length
      }]);
    } // Main worker method. checks all permutations of a given edit length for acceptance.


    function execEditLength() {
      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
        var basePath = void 0;

        var addPath = bestPath[diagonalPath - 1],
            removePath = bestPath[diagonalPath + 1],
            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;

        if (addPath) {
          // No one else is going to attempt to use this value, clear it
          bestPath[diagonalPath - 1] = undefined;
        }

        var canAdd = addPath && addPath.newPos + 1 < newLen,
            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;

        if (!canAdd && !canRemove) {
          // If this path is a terminal then prune
          bestPath[diagonalPath] = undefined;
          continue;
        } // Select the diagonal that we want to branch from. We select the prior
        // path whose position in the new string is the farthest from the origin
        // and does not pass the bounds of the diff graph


        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
          basePath = clonePath(removePath);
          self.pushComponent(basePath.components, undefined, true);
        } else {
          basePath = addPath; // No need to clone, we've pulled it from the list

          basePath.newPos++;
          self.pushComponent(basePath.components, true, undefined);
        }

        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done

        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
        } else {
          // Otherwise track this path as a potential candidate and continue.
          bestPath[diagonalPath] = basePath;
        }
      }

      editLength++;
    } // Performs the length of edit iteration. Is a bit fugly as this has to support the
    // sync and async mode which is never fun. Loops over execEditLength until a value
    // is produced.


    if (callback) {
      (function exec() {
        setTimeout(function () {
          // This should not happen, but we want to be safe.

          /* istanbul ignore next */
          if (editLength > maxEditLength) {
            return callback();
          }

          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength) {
        var ret = execEditLength();

        if (ret) {
          return ret;
        }
      }
    }
  },
  pushComponent: function pushComponent(components, added, removed) {
    var last = components[components.length - 1];

    if (last && last.added === added && last.removed === removed) {
      // We need to clone here as the component clone operation is just
      // as shallow array clone
      components[components.length - 1] = {
        count: last.count + 1,
        added: added,
        removed: removed
      };
    } else {
      components.push({
        count: 1,
        added: added,
        removed: removed
      });
    }
  },
  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
    var newLen = newString.length,
        oldLen = oldString.length,
        newPos = basePath.newPos,
        oldPos = newPos - diagonalPath,
        commonCount = 0;

    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
      newPos++;
      oldPos++;
      commonCount++;
    }

    if (commonCount) {
      basePath.components.push({
        count: commonCount
      });
    }

    basePath.newPos = newPos;
    return oldPos;
  },
  equals: function equals(left, right) {
    if (this.options.comparator) {
      return this.options.comparator(left, right);
    } else {
      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  },
  removeEmpty: function removeEmpty(array) {
    var ret = [];

    for (var i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }

    return ret;
  },
  castInput: function castInput(value) {
    return value;
  },
  tokenize: function tokenize(value) {
    return value.split('');
  },
  join: function join(chars) {
    return chars.join('');
  }
};

function buildValues(diff, components, newString, oldString, useLongestToken) {
  var componentPos = 0,
      componentLen = components.length,
      newPos = 0,
      oldPos = 0;

  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];

    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function (value, i) {
          var oldValue = oldString[oldPos + i];
          return oldValue.length > value.length ? oldValue : value;
        });
        component.value = diff.join(value);
      } else {
        component.value = diff.join(newString.slice(newPos, newPos + component.count));
      }

      newPos += component.count; // Common case

      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention
      // The diffing algorithm is tied to add then remove output and this is the simplest
      // route to get the desired output with minimal overhead.

      if (componentPos && components[componentPos - 1].added) {
        var tmp = components[componentPos - 1];
        components[componentPos - 1] = components[componentPos];
        components[componentPos] = tmp;
      }
    }
  } // Special case handle for when one terminal is ignored (i.e. whitespace).
  // For this case we merge the terminal into the prior string and drop the change.
  // This is only available for string mode.


  var lastComponent = components[componentLen - 1];

  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {
    components[componentLen - 2].value += lastComponent.value;
    components.pop();
  }

  return components;
}

function clonePath(path) {
  return {
    newPos: path.newPos,
    components: path.components.slice(0)
  };
}

var characterDiff = new Diff();

function diffChars(oldStr, newStr, options) {
  return characterDiff.diff(oldStr, newStr, options);
}

function generateOptions(options, defaults) {
  if (typeof